{"ast":null,"code":"/*! p5.speech.js v0.0.1 2015-06-12 */\n\n/* updated v0.0.2 2017-10-17 */\n\n/**\n * @module p5.speech\n * @submodule p5.speech\n * @for p5.speech\n * @main\n */\n\n/**\n *  p5.speech\n *  R. Luke DuBois (dubois@nyu.edu)\n *  ABILITY Lab / Brooklyn Experimental Media Center\n *  New York University\n *  The MIT License (MIT).\n *  \n *  https://github.com/IDMNYU/p5.js-speech\n *\n *  Web Speech API: https://dvcs.w3.org/hg/speech-api/raw-file/tip/speechapi.html\n *  Web Speech Recognition API: https://dvcs.w3.org/hg/speech-api/raw-file/tip/speechapi.html\n */\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) define('p5.speech', ['p5'], function (p5) {\n    factory(p5);\n  });else if (typeof exports === 'object') factory(require('../p5'));else factory(root['p5']);\n})(this, function (p5) {\n  // =============================================================================\n  //                         p5.Speech\n  // =============================================================================\n\n  /**\n   * Base class for a Speech Synthesizer\n   *\n   * @class p5.Speech\n   * @constructor\n   */\n  p5.Speech = function (_dv, _callback) {\n    //\n    // speech synthesizers consist of a single synthesis engine\n    // per window instance, and a variable number of 'utterance'\n    // objects, which can be cached and re-used for, e.g.\n    // auditory UI.\n    //\n    // this implementation assumes a monolithic (one synth, \n    // one phrase at a time) system.\n    //\n    // make a speech synthizer (this will load voices):\n    this.synth = window.speechSynthesis; // make an utterance to use with this synthesizer:\n\n    this.utterance = new SpeechSynthesisUtterance();\n    this.isLoaded = 0; // do we have voices yet?\n    // do we queue new utterances upon firing speak() \n    // or interrupt what's speaking:\n\n    this.interrupt = false; // callback properties to be filled in within the p5 sketch\n    // if the author needs custom callbacks:\n\n    this.onLoad; // fires when voices are loaded and synth is ready\n\n    this.onStart; // fires when an utterance begins...\n\n    this.onPause; // ...is paused...\n\n    this.onResume; // ...resumes...\n\n    this.onEnd; // ...and ends.\n\n    this.voices = []; // array of available voices (dependent on browser/OS)\n    // first parameter of constructor is an initial voice selector\n\n    this.initvoice;\n    if (_dv !== undefined) this.initvoice = _dv;\n    if (_callback !== undefined) this.onLoad = _callback;\n    var that = this; // some bullshit\n    // onvoiceschanged() fires automatically when the synthesizer\n    // is configured and has its voices loaded.  you don't need\n    // to wait for this if you're okay with the default voice.\n    // \n    // we use this function to load the voice array and bind our\n    // custom callback functions.\n\n    window.speechSynthesis.onvoiceschanged = function () {\n      if (that.isLoaded == 0) {\n        // run only once\n        that.voices = window.speechSynthesis.getVoices();\n        that.isLoaded = 1; // we're ready\n\n        console.log(\"p5.Speech: voices loaded!\");\n\n        if (that.initvoice != undefined) {\n          that.setVoice(that.initvoice); // set a custom initial voice\n\n          console.log(\"p5.Speech: initial voice: \" + that.initvoice);\n        } // fire custom onLoad() callback, if it exists:\n\n\n        if (that.onLoad != undefined) that.onLoad(); //\n        // bind other custom callbacks:\n        //\n\n        that.utterance.onstart = function (e) {\n          //console.log(\"STARTED\");\n          if (that.onStart != undefined) that.onStart(e);\n        };\n\n        that.utterance.onpause = function (e) {\n          //console.log(\"PAUSED\");\n          if (that.onPause != undefined) that.onPause(e);\n        };\n\n        that.utterance.onresume = function (e) {\n          //console.log(\"RESUMED\");\n          if (that.onResume != undefined) that.onResume(e);\n        };\n\n        that.utterance.onend = function (e) {\n          //console.log(\"ENDED\");\n          if (that.onEnd != undefined) that.onEnd(e);\n        };\n      }\n    };\n  }; // end p5.Speech constructor\n  // listVoices() - dump voice names to javascript console:\n\n\n  p5.Speech.prototype.listVoices = function () {\n    if (this.isLoaded) {\n      for (var i = 0; i < this.voices.length; i++) {\n        console.log(this.voices[i].name);\n      }\n    } else {\n      console.log(\"p5.Speech: voices not loaded yet!\");\n    }\n  }; // setVoice() - assign voice to speech synthesizer, by name\n  // (using voices found in the voices[] array), or by index.\n\n\n  p5.Speech.prototype.setVoice = function (_v) {\n    // type check so you can set by label or by index:\n    if (typeof _v == 'string') this.utterance.voice = this.voices.filter(function (v) {\n      return v.name == _v;\n    })[0];else if (typeof _v == 'number') this.utterance.voice = this.voices[Math.min(Math.max(_v, 0), this.voices.length - 1)];\n  }; // volume of voice. API range 0.0-1.0.\n\n\n  p5.Speech.prototype.setVolume = function (_v) {\n    this.utterance.volume = Math.min(Math.max(_v, 0.0), 1.0);\n  }; // rate of voice.  not all voices support this feature.\n  // API range 0.1-2.0.  voice will crash out of bounds.\n\n\n  p5.Speech.prototype.setRate = function (_v) {\n    this.utterance.rate = Math.min(Math.max(_v, 0.1), 2.0);\n  }; // pitch of voice.  not all voices support this feature.\n  // API range >0.0-2.0.  voice will crash out of bounds.\n\n\n  p5.Speech.prototype.setPitch = function (_v) {\n    this.utterance.pitch = Math.min(Math.max(_v, 0.01), 2.0);\n  }; // sets the language of the voice.\n\n\n  p5.Speech.prototype.setLang = function (_lang) {\n    this.utterance.lang = _lang;\n  }; // speak a phrase through the current synthesizer:\n\n\n  p5.Speech.prototype.speak = function (_phrase) {\n    if (this.interrupt) this.synth.cancel();\n    this.utterance.text = _phrase;\n    this.synth.speak(this.utterance);\n  }; // not working...\n\n\n  p5.Speech.prototype.pause = function () {\n    this.synth.pause();\n  }; // not working...\n\n\n  p5.Speech.prototype.resume = function () {\n    this.synth.resume();\n  }; // stop current utterance:\n\n\n  p5.Speech.prototype.stop = function () {\n    // not working...\n    //this.synth.stop();\n    this.synth.cancel();\n  }; // kill synthesizer completely, clearing any queued utterances:\n\n\n  p5.Speech.prototype.cancel = function () {\n    this.synth.cancel(); // KILL SYNTH\n  }; // Setting callbacks with functions instead\n\n\n  p5.Speech.prototype.started = function (_cb) {\n    this.onStart = _cb;\n  };\n\n  p5.Speech.prototype.ended = function (_cb) {\n    this.onEnd = _cb;\n  };\n\n  p5.Speech.prototype.paused = function (_cb) {\n    this.onPause = _cb;\n  };\n\n  p5.Speech.prototype.resumed = function (_cb) {\n    this.onResume = _cb;\n  }; // =============================================================================\n  //                         p5.SpeechRec\n  // =============================================================================\n\n  /**\n   * Base class for a Speech Recognizer\n   *\n   * @class p5.SpeechRec\n   * @constructor\n   */\n\n\n  p5.SpeechRec = function (_lang, _callback) {\n    //\n    // speech recognition consists of a recognizer object per \n    // window instance that returns a JSON object containing\n    // recognition.  this JSON object grows when the synthesizer\n    // is in 'continuous' mode, with new recognized phrases\n    // appended into an internal array.\n    //\n    // this implementation returns the full JSON, but also a set\n    // of simple, query-ready properties containing the most\n    // recently recognized speech.\n    //\n    // make a recognizer object.\n    if ('webkitSpeechRecognition' in window) {\n      this.rec = new webkitSpeechRecognition();\n    } else {\n      this.rec = new Object();\n      console.log(\"p5.SpeechRec: webkitSpeechRecognition not supported in this browser.\");\n    } // first parameter is language model (defaults to empty=U.S. English)\n    // no list of valid models in API, but it must use BCP-47.\n    // here's some hints:\n    // http://stackoverflow.com/questions/14257598/what-are-language-codes-for-voice-recognition-languages-in-chromes-implementati\n\n\n    if (_lang !== undefined) this.rec.lang = _lang; // callback properties to be filled in within the p5 sketch\n    // if the author needs custom callbacks:\n\n    this.onResult; // fires when something has been recognized\n\n    this.onStart; // fires when the recognition system is started...\n\n    this.onError; // ...has a problem (e.g. the mic is shut off)...\n\n    this.onEnd; // ...and ends (in non-continuous mode).\n\n    if (_callback !== undefined) this.onResult = _callback; // recognizer properties:\n    // continous mode means the object keeps recognizing speech,\n    // appending new tokens to the internal JSON.\n\n    this.continuous = false; // interimResults means the object will report (i.e. fire its\n    // onresult() callback) more frequently, rather than at pauses\n    // in microphone input.  this gets you quicker, but less accurate,\n    // results.\n\n    this.interimResults = false; // result data:\n    // resultJSON:\n    // this is a full JSON returned by onresult().  it consists of a \n    // SpeechRecognitionEvent object, which contains a (wait for it)\n    // SpeechRecognitionResultList.  this is an array.  in continuous\n    // mode, it will be appended to, not cleared.  each element is a \n    // SpeechRecognition result, which contains a (groan)\n    // SpeechRecognitionAlternative, containing a 'transcript' property.\n    // the 'transcript' is the recognized phrase.  have fun.\n\n    this.resultJSON; // resultValue:\n    // validation flag which indicates whether the recognizer succeeded.  \n    // this is *not* a metric of speech clarity, but rather whether the\n    // speech recognition system successfully connected to and received\n    // a response from the server.  you can construct an if() around this\n    // if you're feeling worried.\n\n    this.resultValue; // resultValue:\n    // the 'transcript' of the most recently recognized speech as a simple\n    // string.  this will be blown out and replaced at every firing of the\n    // onresult() callback.\n\n    this.resultString; // resultConfidence:\n    // the 'confidence' (0-1) of the most recently recognized speech, e.g.\n    // that it reflects what was actually spoken.  you can use this to filter\n    // out potentially bogus recognition tokens.\n\n    this.resultConfidence;\n    var that = this; // some bullshit\n    // onresult() fires automatically when the recognition engine\n    // detects speech, or times out trying.\n    // \n    // it fills up a JSON array internal to the webkitSpeechRecognition\n    // object.  we reference it over in our struct here, and also copy \n    // out the most recently detected phrase and confidence value.\n\n    this.rec.onresult = function (e) {\n      that.resultJSON = e; // full JSON of callback event\n\n      that.resultValue = e.returnValue; // was successful?\n      // store latest result in top-level object struct\n\n      that.resultString = e.results[e.results.length - 1][0].transcript.trim();\n      that.resultConfidence = e.results[e.results.length - 1][0].confidence;\n      if (that.onResult != undefined) that.onResult();\n    }; // fires when the recognition system starts (i.e. when you 'allow'\n    // the mic to be used in the browser).\n\n\n    this.rec.onstart = function (e) {\n      if (that.onStart != undefined) that.onStart(e);\n    }; // fires on a client-side error (server-side errors are expressed \n    // by the resultValue in the JSON coming back as 'false').\n\n\n    this.rec.onerror = function (e) {\n      if (that.onError != undefined) that.onError(e);\n    }; // fires when the recognition finishes, in non-continuous mode.\n\n\n    this.rec.onend = function () {\n      if (that.onEnd != undefined) that.onEnd();\n    };\n  }; // end p5.SpeechRec constructor\n  // start the speech recognition engine.  this will prompt a \n  // security dialog in the browser asking for permission to \n  // use the microphone.  this permission will persist throughout\n  // this one 'start' cycle.  if you need to recognize speech more\n  // than once, use continuous mode rather than firing start() \n  // multiple times in a single script.\n\n\n  p5.SpeechRec.prototype.start = function (_continuous, _interim) {\n    if ('webkitSpeechRecognition' in window) {\n      if (_continuous !== undefined) this.continuous = _continuous;\n      if (_interim !== undefined) this.interimResults = _interim;\n      this.rec.continuous = this.continuous;\n      this.rec.interimResults = this.interimResults;\n      this.rec.start();\n    }\n  };\n});\n/*\ntodo:\n* fix callbacks (pause, resume) in synthesizer.\n* support speech grammar models for scoped auditory UI.\n* support markdown, boundaries, etc for better synthesis tracking.\n* support utterance parser for long phrases.\n*/\n// EOF","map":{"version":3,"sources":["/Users/henrysteinitz/Desktop/soulstream/lib/p5.speech.js"],"names":["root","factory","define","amd","p5","exports","require","Speech","_dv","_callback","synth","window","speechSynthesis","utterance","SpeechSynthesisUtterance","isLoaded","interrupt","onLoad","onStart","onPause","onResume","onEnd","voices","initvoice","undefined","that","onvoiceschanged","getVoices","console","log","setVoice","onstart","e","onpause","onresume","onend","prototype","listVoices","i","length","name","_v","voice","filter","v","Math","min","max","setVolume","volume","setRate","rate","setPitch","pitch","setLang","_lang","lang","speak","_phrase","cancel","text","pause","resume","stop","started","_cb","ended","paused","resumed","SpeechRec","rec","webkitSpeechRecognition","Object","onResult","onError","continuous","interimResults","resultJSON","resultValue","resultString","resultConfidence","onresult","returnValue","results","transcript","trim","confidence","onerror","start","_continuous","_interim"],"mappings":"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","sourcesContent":["/*! p5.speech.js v0.0.1 2015-06-12 */\n/* updated v0.0.2 2017-10-17 */\n/**\n * @module p5.speech\n * @submodule p5.speech\n * @for p5.speech\n * @main\n */\n/**\n *  p5.speech\n *  R. Luke DuBois (dubois@nyu.edu)\n *  ABILITY Lab / Brooklyn Experimental Media Center\n *  New York University\n *  The MIT License (MIT).\n *  \n *  https://github.com/IDMNYU/p5.js-speech\n *\n *  Web Speech API: https://dvcs.w3.org/hg/speech-api/raw-file/tip/speechapi.html\n *  Web Speech Recognition API: https://dvcs.w3.org/hg/speech-api/raw-file/tip/speechapi.html\n */\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd)\n    define('p5.speech', ['p5'], function (p5) { (factory(p5));});\n  else if (typeof exports === 'object')\n    factory(require('../p5'));\n  else\n    factory(root['p5']);\n}(this, function (p5) {\n// =============================================================================\n//                         p5.Speech\n// =============================================================================\n\n\n  /**\n   * Base class for a Speech Synthesizer\n   *\n   * @class p5.Speech\n   * @constructor\n   */\n  p5.Speech = function(_dv, _callback) {\n\n    //\n    // speech synthesizers consist of a single synthesis engine\n    // per window instance, and a variable number of 'utterance'\n    // objects, which can be cached and re-used for, e.g.\n    // auditory UI.\n    //\n    // this implementation assumes a monolithic (one synth, \n    // one phrase at a time) system.\n    //\n\n    // make a speech synthizer (this will load voices):\n    this.synth = window.speechSynthesis;\n\n    // make an utterance to use with this synthesizer:\n    this.utterance = new SpeechSynthesisUtterance();\n\n    this.isLoaded = 0; // do we have voices yet?\n\n    // do we queue new utterances upon firing speak() \n    // or interrupt what's speaking:\n    this.interrupt = false; \n\n    // callback properties to be filled in within the p5 sketch\n    // if the author needs custom callbacks:\n    this.onLoad; // fires when voices are loaded and synth is ready\n    this.onStart; // fires when an utterance begins...\n    this.onPause; // ...is paused...\n    this.onResume; // ...resumes...\n    this.onEnd; // ...and ends.\n\n    this.voices = []; // array of available voices (dependent on browser/OS)\n\n    // first parameter of constructor is an initial voice selector\n    this.initvoice;\n    if(_dv !== undefined) this.initvoice=_dv;\n    if(_callback !== undefined) this.onLoad =_callback;\n\n    var that = this; // some bullshit\n\n    // onvoiceschanged() fires automatically when the synthesizer\n    // is configured and has its voices loaded.  you don't need\n    // to wait for this if you're okay with the default voice.\n    // \n    // we use this function to load the voice array and bind our\n    // custom callback functions.\n    window.speechSynthesis.onvoiceschanged = function() {\n      if(that.isLoaded==0) { // run only once\n        that.voices = window.speechSynthesis.getVoices();\n        that.isLoaded = 1; // we're ready\n        console.log(\"p5.Speech: voices loaded!\");\n\n        if(that.initvoice!=undefined) {\n          that.setVoice(that.initvoice); // set a custom initial voice\n          console.log(\"p5.Speech: initial voice: \" + that.initvoice);\n        }\n\n        // fire custom onLoad() callback, if it exists:\n        if(that.onLoad!=undefined) that.onLoad();\n\n        //\n        // bind other custom callbacks:\n        //\n\n        that.utterance.onstart = function(e) {\n          //console.log(\"STARTED\");\n          if(that.onStart!=undefined) that.onStart(e);     \n        };\n        that.utterance.onpause = function(e) {\n          //console.log(\"PAUSED\");\n          if(that.onPause!=undefined) that.onPause(e);\n        };\n        that.utterance.onresume = function(e) {\n          //console.log(\"RESUMED\");\n          if(that.onResume!=undefined) that.onResume(e);\n        };\n        that.utterance.onend = function(e) {\n          //console.log(\"ENDED\");\n          if(that.onEnd!=undefined) that.onEnd(e); \n        };\n      }\n    };\n\n  };     // end p5.Speech constructor\n\n\n  // listVoices() - dump voice names to javascript console:\n  p5.Speech.prototype.listVoices = function() {\n    if(this.isLoaded)\n    {\n      for(var i = 0;i<this.voices.length;i++)\n      {\n        console.log(this.voices[i].name);\n      }\n    }\n    else\n    {\n    \tconsole.log(\"p5.Speech: voices not loaded yet!\")\n    }\n  };\n\n  // setVoice() - assign voice to speech synthesizer, by name\n  // (using voices found in the voices[] array), or by index.\n  p5.Speech.prototype.setVoice = function(_v) {\n    // type check so you can set by label or by index:\n    if(typeof(_v)=='string') this.utterance.voice = this.voices.filter(function(v) { return v.name == _v; })[0];\n    else if(typeof(_v)=='number') this.utterance.voice = this.voices[Math.min(Math.max(_v,0),this.voices.length-1)];\n  };\n\n  // volume of voice. API range 0.0-1.0.\n  p5.Speech.prototype.setVolume = function(_v) {\n    this.utterance.volume = Math.min(Math.max(_v, 0.0), 1.0);\n  };\n\n  // rate of voice.  not all voices support this feature.\n  // API range 0.1-2.0.  voice will crash out of bounds.\n  p5.Speech.prototype.setRate = function(_v) {\n    this.utterance.rate = Math.min(Math.max(_v, 0.1), 2.0);\n  };\n\n  // pitch of voice.  not all voices support this feature.\n  // API range >0.0-2.0.  voice will crash out of bounds.\n  p5.Speech.prototype.setPitch = function(_v) {\n    this.utterance.pitch = Math.min(Math.max(_v, 0.01), 2.0);\n  };\n\n  // sets the language of the voice.\n  p5.Speech.prototype.setLang = function(_lang) {\n    this.utterance.lang = _lang;\n}\n\n  // speak a phrase through the current synthesizer:\n  p5.Speech.prototype.speak = function(_phrase) {\n    if(this.interrupt) this.synth.cancel();\n    this.utterance.text = _phrase;\n\n    this.synth.speak(this.utterance);\n  };\n\n  // not working...\n  p5.Speech.prototype.pause = function() {\n    this.synth.pause();\n  };\n\n  // not working...\n  p5.Speech.prototype.resume = function() {\n    this.synth.resume();\n  };\n\n  // stop current utterance:\n  p5.Speech.prototype.stop = function() {\n    // not working...\n    //this.synth.stop();\n    this.synth.cancel();\n  };\n\n  // kill synthesizer completely, clearing any queued utterances:\n  p5.Speech.prototype.cancel = function() {\n    this.synth.cancel(); // KILL SYNTH\n  };\n\n  // Setting callbacks with functions instead\n  p5.Speech.prototype.started = function(_cb) {\n   this.onStart = _cb;\n  }\n\n  p5.Speech.prototype.ended = function(_cb) {\n    this.onEnd = _cb;\n  }\n\n  p5.Speech.prototype.paused = function(_cb) {\n    this.onPause = _cb;\n  }\n\n  p5.Speech.prototype.resumed = function(_cb) {\n    this.onResume = _cb;\n  }\n\n// =============================================================================\n//                         p5.SpeechRec\n// =============================================================================\n\n\n  /**\n   * Base class for a Speech Recognizer\n   *\n   * @class p5.SpeechRec\n   * @constructor\n   */\n  p5.SpeechRec = function(_lang, _callback) {\n\n    //\n    // speech recognition consists of a recognizer object per \n    // window instance that returns a JSON object containing\n    // recognition.  this JSON object grows when the synthesizer\n    // is in 'continuous' mode, with new recognized phrases\n    // appended into an internal array.\n    //\n    // this implementation returns the full JSON, but also a set\n    // of simple, query-ready properties containing the most\n    // recently recognized speech.\n    //\n\n    // make a recognizer object.\n    if('webkitSpeechRecognition' in window) {\n      this.rec = new webkitSpeechRecognition();\n    }\n    else {\n      this.rec = new Object();\n      console.log(\"p5.SpeechRec: webkitSpeechRecognition not supported in this browser.\");\n    }\n\n    // first parameter is language model (defaults to empty=U.S. English)\n    // no list of valid models in API, but it must use BCP-47.\n    // here's some hints:\n    // http://stackoverflow.com/questions/14257598/what-are-language-codes-for-voice-recognition-languages-in-chromes-implementati\n    if(_lang !== undefined) this.rec.lang=_lang;\n\n    // callback properties to be filled in within the p5 sketch\n    // if the author needs custom callbacks:\n    this.onResult; // fires when something has been recognized\n    this.onStart; // fires when the recognition system is started...\n    this.onError; // ...has a problem (e.g. the mic is shut off)...\n    this.onEnd; // ...and ends (in non-continuous mode).\n    if(_callback !== undefined) this.onResult=_callback;\n\n    // recognizer properties:\n\n    // continous mode means the object keeps recognizing speech,\n    // appending new tokens to the internal JSON.\n    this.continuous = false; \n    // interimResults means the object will report (i.e. fire its\n    // onresult() callback) more frequently, rather than at pauses\n    // in microphone input.  this gets you quicker, but less accurate,\n    // results.\n    this.interimResults = false;\n\n    // result data:\n\n    // resultJSON:\n    // this is a full JSON returned by onresult().  it consists of a \n    // SpeechRecognitionEvent object, which contains a (wait for it)\n    // SpeechRecognitionResultList.  this is an array.  in continuous\n    // mode, it will be appended to, not cleared.  each element is a \n    // SpeechRecognition result, which contains a (groan)\n    // SpeechRecognitionAlternative, containing a 'transcript' property.\n    // the 'transcript' is the recognized phrase.  have fun.\n    this.resultJSON; \n    // resultValue:\n    // validation flag which indicates whether the recognizer succeeded.  \n    // this is *not* a metric of speech clarity, but rather whether the\n    // speech recognition system successfully connected to and received\n    // a response from the server.  you can construct an if() around this\n    // if you're feeling worried.\n    this.resultValue; \n    // resultValue:\n    // the 'transcript' of the most recently recognized speech as a simple\n    // string.  this will be blown out and replaced at every firing of the\n    // onresult() callback.\n    this.resultString; \n    // resultConfidence:\n    // the 'confidence' (0-1) of the most recently recognized speech, e.g.\n    // that it reflects what was actually spoken.  you can use this to filter\n    // out potentially bogus recognition tokens.\n    this.resultConfidence; \n\n    var that = this; // some bullshit\n\n    // onresult() fires automatically when the recognition engine\n    // detects speech, or times out trying.\n    // \n    // it fills up a JSON array internal to the webkitSpeechRecognition\n    // object.  we reference it over in our struct here, and also copy \n    // out the most recently detected phrase and confidence value.\n    this.rec.onresult = function(e) { \n      that.resultJSON = e; // full JSON of callback event\n      that.resultValue = e.returnValue; // was successful?\n      // store latest result in top-level object struct\n      that.resultString = e.results[e.results.length-1][0].transcript.trim();\n      that.resultConfidence = e.results[e.results.length-1][0].confidence;\n      if(that.onResult!=undefined) that.onResult();\n    };\n\n    // fires when the recognition system starts (i.e. when you 'allow'\n    // the mic to be used in the browser).\n    this.rec.onstart = function(e) {\n      if(that.onStart!=undefined) that.onStart(e);\n    };\n    // fires on a client-side error (server-side errors are expressed \n    // by the resultValue in the JSON coming back as 'false').\n    this.rec.onerror = function(e) {\n      if(that.onError!=undefined) that.onError(e);\n    };\n    // fires when the recognition finishes, in non-continuous mode.\n    this.rec.onend = function() {\n      if(that.onEnd!=undefined) that.onEnd();\n    };\n\n  }; // end p5.SpeechRec constructor\n\n  // start the speech recognition engine.  this will prompt a \n  // security dialog in the browser asking for permission to \n  // use the microphone.  this permission will persist throughout\n  // this one 'start' cycle.  if you need to recognize speech more\n  // than once, use continuous mode rather than firing start() \n  // multiple times in a single script.\n  p5.SpeechRec.prototype.start = function(_continuous, _interim) {\n    if('webkitSpeechRecognition' in window) {\n      if(_continuous !== undefined) this.continuous = _continuous;\n      if(_interim !== undefined) this.interimResults = _interim;\n      this.rec.continuous = this.continuous;\n      this.rec.interimResults = this.interimResults;\n      this.rec.start();\n    }\n  };\n\n}));\n\n/*\ntodo:\n* fix callbacks (pause, resume) in synthesizer.\n* support speech grammar models for scoped auditory UI.\n* support markdown, boundaries, etc for better synthesis tracking.\n* support utterance parser for long phrases.\n*/\n\n// EOF\n\n\n\n"]},"metadata":{},"sourceType":"script"}