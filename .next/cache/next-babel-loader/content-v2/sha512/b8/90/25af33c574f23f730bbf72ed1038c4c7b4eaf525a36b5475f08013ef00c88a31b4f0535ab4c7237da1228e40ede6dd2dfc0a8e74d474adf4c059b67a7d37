{"ast":null,"code":"import { createHash, randomBytes } from 'crypto';\nimport prisma from '../../../lib/prisma.js';\nexport default (async (req, res) => {\n  const {\n    email,\n    finalHash,\n    salt\n  } = req.body;\n  console.log(email);\n  const {\n    passwordHash\n  } = prisma.account.findUnique({\n    where: {\n      email\n    },\n    include: {\n      passwordHash: true\n    }\n  }); // Salt and hash the server's password hash. Double hash is used\n  // so that we never store raw passwords. The second hash is salted.\n\n  const hash = createHash('sha256');\n  hash.update(salt + passwordHash);\n  const serverFinalHash = hash.digest();\n\n  if (serverFinalHash !== finalHash) {\n    res.status(400);\n  }\n\n  const sessionToken = randomBytes(64).toString('hex');\n  const account = await prisma.account.update({\n    where: {\n      email\n    },\n    data: {\n      sessionToken\n    }\n  });\n  console.log(account);\n  res.json(account);\n});","map":{"version":3,"sources":["/Users/henrysteinitz/Desktop/soulstream/pages/api/auth/signin.js"],"names":["createHash","randomBytes","prisma","req","res","email","finalHash","salt","body","console","log","passwordHash","account","findUnique","where","include","hash","update","serverFinalHash","digest","status","sessionToken","toString","data","json"],"mappings":"AAAA,SAASA,UAAT,EAAqBC,WAArB,QAAwC,QAAxC;AACA,OAAOC,MAAP,MAAmB,wBAAnB;AAGA,gBAAe,OAAOC,GAAP,EAAYC,GAAZ,KAAoB;AACjC,QAAM;AAAEC,IAAAA,KAAF;AAASC,IAAAA,SAAT;AAAoBC,IAAAA;AAApB,MAA6BJ,GAAG,CAACK,IAAvC;AACAC,EAAAA,OAAO,CAACC,GAAR,CAAYL,KAAZ;AACA,QAAM;AAAEM,IAAAA;AAAF,MAAmBT,MAAM,CAACU,OAAP,CAAeC,UAAf,CAA0B;AAClDC,IAAAA,KAAK,EAAE;AAAET,MAAAA;AAAF,KAD2C;AAElDU,IAAAA,OAAO,EAAE;AACRJ,MAAAA,YAAY,EAAE;AADN;AAFyC,GAA1B,CAAzB,CAHiC,CAUjC;AACA;;AACA,QAAMK,IAAI,GAAGhB,UAAU,CAAC,QAAD,CAAvB;AACAgB,EAAAA,IAAI,CAACC,MAAL,CAAYV,IAAI,GAAGI,YAAnB;AACA,QAAMO,eAAe,GAAGF,IAAI,CAACG,MAAL,EAAxB;;AACA,MAAID,eAAe,KAAKZ,SAAxB,EAAmC;AAClCF,IAAAA,GAAG,CAACgB,MAAJ,CAAW,GAAX;AACA;;AAED,QAAMC,YAAY,GAAGpB,WAAW,CAAC,EAAD,CAAX,CAAgBqB,QAAhB,CAAyB,KAAzB,CAArB;AACA,QAAMV,OAAO,GAAG,MAAMV,MAAM,CAACU,OAAP,CAAeK,MAAf,CAAsB;AAC3CH,IAAAA,KAAK,EAAE;AAAET,MAAAA;AAAF,KADoC;AAE3CkB,IAAAA,IAAI,EAAE;AAAEF,MAAAA;AAAF;AAFqC,GAAtB,CAAtB;AAIAZ,EAAAA,OAAO,CAACC,GAAR,CAAYE,OAAZ;AACAR,EAAAA,GAAG,CAACoB,IAAJ,CAASZ,OAAT;AACD,CA1BD","sourcesContent":["import { createHash, randomBytes } from 'crypto';\nimport prisma from '../../../lib/prisma.js';\n\n\nexport default async (req, res) => {\n  const { email, finalHash, salt } = req.body;\n  console.log(email)\n  const { passwordHash } = prisma.account.findUnique({\n  \twhere: { email },\n  \tinclude: { \n  \t\tpasswordHash: true \n  \t}\n  });\n\n  // Salt and hash the server's password hash. Double hash is used\n  // so that we never store raw passwords. The second hash is salted.\n  const hash = createHash('sha256');\n  hash.update(salt + passwordHash);\n  const serverFinalHash = hash.digest()\n  if (serverFinalHash !== finalHash) {\n  \tres.status(400)\n  }\n\n  const sessionToken = randomBytes(64).toString('hex')\n  const account = await prisma.account.update({\n  \twhere: { email },\n  \tdata: { sessionToken }\n  });\n  console.log(account)\n  res.json(account);\n}\n\n"]},"metadata":{},"sourceType":"module"}