{"ast":null,"code":"import { createHash, randomBytes } from 'crypto';\nimport prisma from '../../../lib/prisma.js';\nexport default (async (req, res) => {\n  const {\n    email,\n    finalHash,\n    salt\n  } = req.body;\n  console.log(email);\n  const account = await prisma.account.findUnique({\n    where: {\n      email\n    },\n    select: {\n      passwordHash: true\n    }\n  }); // Salt and hash the server's password hash. Double hash is used\n  // so that we never store raw passwords. The second hash is salted.\n\n  console.log(account.passwordHash);\n  const hash = createHash('sha256');\n  hash.update(salt + account.passwordHash);\n  const serverFinalHash = hash.digest('hex');\n  console.log(serverFinalHash);\n\n  if (serverFinalHash !== finalHash) {\n    res.status(400);\n  }\n\n  const sessionToken = randomBytes(64).toString('hex');\n  const account2 = await prisma.account.update({\n    where: {\n      email\n    },\n    data: {\n      sessionToken\n    }\n  });\n  console.log(account2);\n  res.json(account2);\n});","map":{"version":3,"sources":["/Users/henrysteinitz/Desktop/soulstream/pages/api/auth/signin.js"],"names":["createHash","randomBytes","prisma","req","res","email","finalHash","salt","body","console","log","account","findUnique","where","select","passwordHash","hash","update","serverFinalHash","digest","status","sessionToken","toString","account2","data","json"],"mappings":"AAAA,SAASA,UAAT,EAAqBC,WAArB,QAAwC,QAAxC;AACA,OAAOC,MAAP,MAAmB,wBAAnB;AAGA,gBAAe,OAAOC,GAAP,EAAYC,GAAZ,KAAoB;AACjC,QAAM;AAAEC,IAAAA,KAAF;AAASC,IAAAA,SAAT;AAAoBC,IAAAA;AAApB,MAA6BJ,GAAG,CAACK,IAAvC;AACAC,EAAAA,OAAO,CAACC,GAAR,CAAYL,KAAZ;AACA,QAAMM,OAAO,GAAG,MAAMT,MAAM,CAACS,OAAP,CAAeC,UAAf,CAA0B;AAC/CC,IAAAA,KAAK,EAAE;AAAER,MAAAA;AAAF,KADwC;AAE/CS,IAAAA,MAAM,EAAE;AACPC,MAAAA,YAAY,EAAE;AADP;AAFuC,GAA1B,CAAtB,CAHiC,CAUjC;AACA;;AACAN,EAAAA,OAAO,CAACC,GAAR,CAAYC,OAAO,CAACI,YAApB;AACA,QAAMC,IAAI,GAAGhB,UAAU,CAAC,QAAD,CAAvB;AACAgB,EAAAA,IAAI,CAACC,MAAL,CAAYV,IAAI,GAAGI,OAAO,CAACI,YAA3B;AACA,QAAMG,eAAe,GAAGF,IAAI,CAACG,MAAL,CAAY,KAAZ,CAAxB;AACAV,EAAAA,OAAO,CAACC,GAAR,CAAYQ,eAAZ;;AACA,MAAIA,eAAe,KAAKZ,SAAxB,EAAmC;AAClCF,IAAAA,GAAG,CAACgB,MAAJ,CAAW,GAAX;AACA;;AAED,QAAMC,YAAY,GAAGpB,WAAW,CAAC,EAAD,CAAX,CAAgBqB,QAAhB,CAAyB,KAAzB,CAArB;AACA,QAAMC,QAAQ,GAAG,MAAMrB,MAAM,CAACS,OAAP,CAAeM,MAAf,CAAsB;AAC5CJ,IAAAA,KAAK,EAAE;AAAER,MAAAA;AAAF,KADqC;AAE5CmB,IAAAA,IAAI,EAAE;AAAEH,MAAAA;AAAF;AAFsC,GAAtB,CAAvB;AAIAZ,EAAAA,OAAO,CAACC,GAAR,CAAYa,QAAZ;AACAnB,EAAAA,GAAG,CAACqB,IAAJ,CAASF,QAAT;AACD,CA5BD","sourcesContent":["import { createHash, randomBytes } from 'crypto';\nimport prisma from '../../../lib/prisma.js';\n\n\nexport default async (req, res) => {\n  const { email, finalHash, salt } = req.body;\n  console.log(email)\n  const account = await prisma.account.findUnique({\n  \twhere: { email },\n  \tselect: { \n  \t\tpasswordHash: true \n  \t}\n  });\n\n  // Salt and hash the server's password hash. Double hash is used\n  // so that we never store raw passwords. The second hash is salted.\n  console.log(account.passwordHash)\n  const hash = createHash('sha256');\n  hash.update(salt + account.passwordHash);\n  const serverFinalHash = hash.digest('hex')\n  console.log(serverFinalHash)\n  if (serverFinalHash !== finalHash) {\n  \tres.status(400)\n  }\n\n  const sessionToken = randomBytes(64).toString('hex')\n  const account2 = await prisma.account.update({\n  \twhere: { email },\n  \tdata: { sessionToken }\n  });\n  console.log(account2)\n  res.json(account2);\n}\n\n"]},"metadata":{},"sourceType":"module"}