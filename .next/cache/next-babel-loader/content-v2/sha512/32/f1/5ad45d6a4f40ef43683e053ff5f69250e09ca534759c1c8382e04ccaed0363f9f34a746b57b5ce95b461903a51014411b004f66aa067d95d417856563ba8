{"ast":null,"code":"import { createHash, randomBytes } from 'crypto';\nimport prisma from '../../../lib/prisma.js';\nexport default (async (req, res) => {\n  const {\n    email,\n    finalHash,\n    salt\n  } = req.body;\n  console.log(email);\n  const account = await prisma.account.findUnique({\n    where: {\n      email\n    },\n    select: {\n      passwordHash: true\n    }\n  }); // Salt and hash the server's password hash. Double hash is used\n  // so that we never store raw passwords. The second hash is salted.\n\n  console.log(Object.getOwnPropertyNames(account));\n  const hash = createHash('sha256');\n  hash.update(salt + passwordHash);\n  const serverFinalHash = hash.digest();\n  console.log(serverFinalHash);\n\n  if (serverFinalHash !== finalHash) {\n    res.status(400);\n  }\n\n  const sessionToken = randomBytes(64).toString('hex');\n  const account2 = await prisma.account.update({\n    where: {\n      email\n    },\n    data: {\n      sessionToken\n    }\n  });\n  console.log(account2);\n  res.json(account2);\n});","map":{"version":3,"sources":["/Users/henrysteinitz/Desktop/soulstream/pages/api/auth/signin.js"],"names":["createHash","randomBytes","prisma","req","res","email","finalHash","salt","body","console","log","account","findUnique","where","select","passwordHash","Object","getOwnPropertyNames","hash","update","serverFinalHash","digest","status","sessionToken","toString","account2","data","json"],"mappings":"AAAA,SAASA,UAAT,EAAqBC,WAArB,QAAwC,QAAxC;AACA,OAAOC,MAAP,MAAmB,wBAAnB;AAGA,gBAAe,OAAOC,GAAP,EAAYC,GAAZ,KAAoB;AACjC,QAAM;AAAEC,IAAAA,KAAF;AAASC,IAAAA,SAAT;AAAoBC,IAAAA;AAApB,MAA6BJ,GAAG,CAACK,IAAvC;AACAC,EAAAA,OAAO,CAACC,GAAR,CAAYL,KAAZ;AACA,QAAMM,OAAO,GAAG,MAAMT,MAAM,CAACS,OAAP,CAAeC,UAAf,CAA0B;AAC/CC,IAAAA,KAAK,EAAE;AAAER,MAAAA;AAAF,KADwC;AAE/CS,IAAAA,MAAM,EAAE;AACPC,MAAAA,YAAY,EAAE;AADP;AAFuC,GAA1B,CAAtB,CAHiC,CAUjC;AACA;;AACAN,EAAAA,OAAO,CAACC,GAAR,CAAYM,MAAM,CAACC,mBAAP,CAA2BN,OAA3B,CAAZ;AACA,QAAMO,IAAI,GAAGlB,UAAU,CAAC,QAAD,CAAvB;AACAkB,EAAAA,IAAI,CAACC,MAAL,CAAYZ,IAAI,GAAGQ,YAAnB;AACA,QAAMK,eAAe,GAAGF,IAAI,CAACG,MAAL,EAAxB;AACAZ,EAAAA,OAAO,CAACC,GAAR,CAAYU,eAAZ;;AACA,MAAIA,eAAe,KAAKd,SAAxB,EAAmC;AAClCF,IAAAA,GAAG,CAACkB,MAAJ,CAAW,GAAX;AACA;;AAED,QAAMC,YAAY,GAAGtB,WAAW,CAAC,EAAD,CAAX,CAAgBuB,QAAhB,CAAyB,KAAzB,CAArB;AACA,QAAMC,QAAQ,GAAG,MAAMvB,MAAM,CAACS,OAAP,CAAeQ,MAAf,CAAsB;AAC5CN,IAAAA,KAAK,EAAE;AAAER,MAAAA;AAAF,KADqC;AAE5CqB,IAAAA,IAAI,EAAE;AAAEH,MAAAA;AAAF;AAFsC,GAAtB,CAAvB;AAIAd,EAAAA,OAAO,CAACC,GAAR,CAAYe,QAAZ;AACArB,EAAAA,GAAG,CAACuB,IAAJ,CAASF,QAAT;AACD,CA5BD","sourcesContent":["import { createHash, randomBytes } from 'crypto';\nimport prisma from '../../../lib/prisma.js';\n\n\nexport default async (req, res) => {\n  const { email, finalHash, salt } = req.body;\n  console.log(email)\n  const account = await prisma.account.findUnique({\n  \twhere: { email },\n  \tselect: { \n  \t\tpasswordHash: true \n  \t}\n  });\n\n  // Salt and hash the server's password hash. Double hash is used\n  // so that we never store raw passwords. The second hash is salted.\n  console.log(Object.getOwnPropertyNames(account))\n  const hash = createHash('sha256');\n  hash.update(salt + passwordHash);\n  const serverFinalHash = hash.digest()\n  console.log(serverFinalHash)\n  if (serverFinalHash !== finalHash) {\n  \tres.status(400)\n  }\n\n  const sessionToken = randomBytes(64).toString('hex')\n  const account2 = await prisma.account.update({\n  \twhere: { email },\n  \tdata: { sessionToken }\n  });\n  console.log(account2)\n  res.json(account2);\n}\n\n"]},"metadata":{},"sourceType":"module"}